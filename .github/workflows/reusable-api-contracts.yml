# .github/workflows/reusable-api-contracts.yml
#
# Reusable workflow for API-first repositories (e.g., wendara-api-definitions).
# It validates OpenAPI contracts, enforces semantic versioning with an OAS diff guard,
# optionally generates Redoc HTML previews, publishes only CHANGED APIs as artifacts,
# and after a stable release on main, opens an automatic sync PR main â†’ develop.
#
# Inputs (set by the caller workflow):
#   - java_version: string (default "21")      -> Java toolchain for Gradle tasks
#   - node_version: string (default "22")      -> Node.js version for Redoc/linters
#   - run_redoc: boolean (default true)        -> Build Redoc previews if true
#   - publish_enabled: boolean (default false) -> Publish artifacts if true (use on push, not on PR)
#   - require_listed_only: boolean (default true) -> If true, only APIs present in root metadata.yml are eligible
#
# Secrets (provided by the caller):
#   - PACKAGES_TOKEN -> Token with packages:write (usually the caller's GITHUB_TOKEN)
#
# Outputs:
#   - changed_specs: space-separated list of changed openapi.yaml paths
#   - any_changed: "true"/"false"
#   - released: "true"/"false" (only true when publishing stable on main)
#
# Notes:
# - This workflow assumes the consumer repo has:
#     apis/<transport>/<apiName>/<major>/openapi.yaml
#     (optional) per-API metadata.yml next to each spec
#     (optional) root metadata.yml at repo root (as a whitelist index)
#     (optional) .redocly.yaml at repo root
# - All helper scripts are available under the scripts/ directory in this repository.
# - External dependencies required by some scripts:
#     - oasdiff (CLI binary, installed in the runner)
#     - yq (mikefarah, for YAML parsing)
#     - reviewdog (for PR annotations)
#
# Usage Example:
#   To call this workflow from another repo, use workflow_call and provide the required inputs/secrets.
#   All scripts are invoked using their relative path from the repo root, e.g.:
#     scripts/api-first/api-oasdiff-guard.sh origin/main HEAD apis/emotion-journal/openapi.yaml
#     scripts/api-first/redoc-build.sh <spec> <output.html>
#
# Jobs Overview:
#   - detect: Detects changed OpenAPI specs and metadata.
#   - validate: Lints specs and checks Conventional Commits.
#   - guard: Enforces semantic versioning using oasdiff.
#   - redoc: Optionally builds Redoc HTML previews for changed specs.
#   - publish: Publishes changed specs as Maven artifacts (if enabled).
#   - sync: After stable publish, opens a PR to sync main â†’ develop.
#
# For more details, see the README.md in this repository

name: Reusable Â· API Contracts

on:
  workflow_call:
    inputs:
      java_version:
        description: "Java version for Gradle"
        required: false
        default: "21"
        type: string
      node_version:
        description: "Node version for Redoc/linters"
        required: false
        default: "22"
        type: string
      run_redoc:
        description: "Generate Redoc HTML previews"
        required: false
        default: true
        type: boolean
      publish_enabled:
        description: "Publish artifacts (use on push, not PR)"
        required: false
        default: false
        type: boolean
      require_listed_only:
        description: "Only consider APIs listed in root metadata.yml"
        required: false
        default: true
        type: boolean
    secrets:
      PACKAGES_TOKEN:
        required: false
    outputs:
      changed_specs:
        description: "Space-separated list of changed openapi.yaml paths"
        value: ${{ jobs.detect.outputs.changed_specs }}
      any_changed:
        description: "Whether any OpenAPI spec changed"
        value: ${{ jobs.detect.outputs.any_changed }}
      released:
        description: "Whether we published a stable release on main"
        value: ${{ jobs.publish.outputs.released }}

permissions:
  contents: read
  packages: write
  pull-requests: write

jobs:

  detect:
    # Detect which API specs changed in this push/PR.
    # The result is a space-separated list of apis/*/*/*/openapi.yaml.
    name: Detect changed API specs
    runs-on: ubuntu-latest
    env:
      REVIEWDOG_GITHUB_API_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    outputs:
      changed_specs: ${{ steps.collect.outputs.changed_specs }}
      any_changed: ${{ steps.collect.outputs.any_changed }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: List changed files (OpenAPI specs + per-API metadata + root metadata + redoc config)
        id: changed
        uses: tj-actions/changed-files@v44
        with:
          files: |
            apis/*/*/*/openapi.yaml
            apis/*/*/*/metadata.yml
            metadata.yml
            .redocly.yaml

      - name: Install yq (for version bump detection)
        run: |
          sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/download/v4.44.3/yq_linux_amd64
          sudo chmod +x /usr/local/bin/yq
          yq --version

      - name: Collect changed specs (no root expansion, only version-bumped per-API metadata)
        id: collect
        shell: bash
        run: |
          set -euo pipefail
          IFS=$'\n'

          BASE_REF="${{ github.event.pull_request.base.sha || github.event.before || 'origin/main' }}"
          HEAD_REF="${{ github.sha }}"

          # 1) Gather directly changed specs
          DIRECT_SPECS=()
          for f in ${{ steps.changed.outputs.all_changed_files }}; do
            if [[ "$f" == apis/*/*/*/openapi.yaml ]]; then
              DIRECT_SPECS+=("$f")
            fi
          done

          # 2) Per-API metadata.yml: include ONLY if version changed
          VERSION_BUMP_SPECS=()
          for meta in ${{ steps.changed.outputs.all_changed_files }}; do
            if [[ "$meta" == apis/*/*/*/metadata.yml ]]; then
              old_ver="$(git show "${BASE_REF}:${meta}" 2>/dev/null | yq '.version' || true)"
              new_ver="$(yq '.version' "$meta" || true)"
              if [[ -n "$old_ver" && -n "$new_ver" && "$old_ver" != "$new_ver" ]]; then
                api_dir="$(dirname "$meta")"
                if [[ -f "$api_dir/openapi.yaml" ]]; then
                  VERSION_BUMP_SPECS+=("$api_dir/openapi.yaml")
                fi
              fi
            fi
          done

          # 3) NEVER expand all specs when root metadata.yml changes.
          #    Root index may affect whitelist, but should not force republish by itself.

          # Merge and deduplicate
          ALL=("${DIRECT_SPECS[@]}" "${VERSION_BUMP_SPECS[@]}")
          if [[ ${#ALL[@]} -eq 0 ]]; then
            echo "changed_specs=" >> $GITHUB_OUTPUT
            echo "any_changed=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          mapfile -t UNIQUE < <(printf "%s\n" "${ALL[@]}" | sort -u)
          CHANGED_SPECS="$(printf "%s " "${UNIQUE[@]}")"
          echo "Changed specs (post-filter):"
          printf "  - %s\n" "${UNIQUE[@]}"
          echo "changed_specs=${CHANGED_SPECS}" >> $GITHUB_OUTPUT
          echo "any_changed=true" >> $GITHUB_OUTPUT

  validate:
    # Lint OpenAPI specs with Redocly (if present) and enforce Conventional Commits (on PR).
    name: Lint + Conventional Commits
    runs-on: ubuntu-latest
    needs: [ detect ]
    if: needs.detect.outputs.any_changed == 'true'
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # Conventional Commits check (PRs only). No local hooks required.
      - name: Commitlint (Conventional Commits)
        if: github.event_name == 'pull_request'
        uses: wagoid/commitlint-github-action@v6
        with:
          configFile: .commitlintrc.json

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: ${{ inputs.node_version }}

      - name: Install Redocly CLI
        run: npm i -g @redocly/cli

      - name: Redocly lint (all changed specs)
        shell: bash
        run: |
          set -euo pipefail
          IFS=$'\n'
          for spec in ${{ needs.detect.outputs.changed_specs }}; do
            [ -z "$spec" ] && continue
            echo "Linting '${spec}'"
            redocly lint "$spec"
          done

  guard:
    # Semantic diff guard with oasdiff; fails on breaking changes when version bump is insufficient.
    name: Semantic diff guard (oasdiff)
    runs-on: ubuntu-latest
    needs: [ detect ]
    if: needs.detect.outputs.any_changed == 'true'
    # Explicit permissions for reviewdog annotations inside reusable workflow.
    permissions:
      contents: read
      pull-requests: write
      checks: write
    # Pass token so reviewdog can publish PR checks from reusable workflow.
    env:
      REVIEWDOG_GITHUB_API_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    steps:
      - name: Checkout consumer repo (full history)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Checkout ci-actions (scripts)
        uses: actions/checkout@v4
        with:
          repository: wendara-org/wendara-ci-actions
          path: .wendara-ci-actions
          ref: main

      - name: Make scripts executable
        run: chmod -R +x .wendara-ci-actions/scripts

      - name: Install yq & reviewdog
        run: |
          sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/download/v4.44.3/yq_linux_amd64
          sudo chmod +x /usr/local/bin/yq
          curl -sfL https://raw.githubusercontent.com/reviewdog/reviewdog/master/install.sh | sh -s -- -b /usr/local/bin

      - name: Install oasdiff (pinned, with fallback)
        run: |
          set -euo pipefail
          VERSION="v1.11.7"
          TMP="$(mktemp -d)"
          cd "$TMP"

          # Attempt direct asset first (fast path)
          if curl -fsSL -o oasdiff "https://github.com/oasdiff/oasdiff/releases/download/${VERSION}/oasdiff-linux-amd64"; then
            chmod +x oasdiff || true
            BIN="./oasdiff"
          else
            echo "Direct asset missing; using official installer..."
            curl -fsSL https://raw.githubusercontent.com/oasdiff/oasdiff/main/install.sh | sh -s -- -b . "${VERSION}"
            # Installer may drop binary locally OR directly into /usr/local/bin depending on perms
            BIN="./oasdiff"
            if ! [ -x "$BIN" ]; then
              BIN="/usr/local/bin/oasdiff"
            fi
          fi

          # Final validation
          if ! [ -x "$BIN" ]; then
            echo "oasdiff not found at ${BIN}"
            exit 127
          fi
          file "$BIN" | grep -qi 'ELF' || { echo "Invalid oasdiff binary"; exit 127; }

          # Ensure it's available in PATH
          if [ "$BIN" != "/usr/local/bin/oasdiff" ]; then
            sudo install -m 0755 "$BIN" /usr/local/bin/oasdiff
          fi
          /usr/local/bin/oasdiff --version

      - name: Run semantic guard
        env:
          CHANGED_SPECS: ${{ needs.detect.outputs.changed_specs }}
        run: |
          set -euo pipefail
          read -r -a SPECS <<< "${CHANGED_SPECS}"
          for spec in "${SPECS[@]}"; do
            [ -z "$spec" ] && continue
            echo "Running semantic diff for '${spec}'"
            .wendara-ci-actions/scripts/api-first/api-oasdiff-guard.sh origin/main HEAD "$spec"
          done

      - name: Generate API changelog (oasdiff)
        run: |
          chmod +x .wendara-ci-actions/scripts/api-first/oasdiff-changelog.sh
          BASE_REF="${{ github.event.pull_request.base.sha || github.event.before || 'origin/main' }}"
          HEAD_REF="${{ github.sha }}"
          .wendara-ci-actions/scripts/api-first/oasdiff-changelog.sh "$BASE_REF" "$HEAD_REF" CHANGELOG.md

      - name: Show changelog in logs
        if: always()
        run: |
          echo "==================== CHANGELOG.md ===================="
          cat CHANGELOG.md || echo "No changelog file generated."
          echo "======================================================"

      - name: Upload changelog artifact
        uses: actions/upload-artifact@v4
        with:
          name: api-changelog
          path: CHANGELOG.md
          retention-days: 7

  redoc:
    # Optional Redoc HTML previews for reviewers; attached as artifacts.
    name: Build Redoc previews
    runs-on: ubuntu-latest
    needs: [ detect ]
    if: needs.detect.outputs.any_changed == 'true' && inputs.run_redoc
    steps:
      - name: Checkout (include scripts)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          repository: ${{ github.repository }}

      - name: Checkout ci-actions (to get scripts)
        uses: actions/checkout@v4
        with:
          repository: wendara-org/wendara-ci-actions
          path: .wendara-ci-actions
          ref: main

      - name: Make scripts executable
        run: chmod -R +x .wendara-ci-actions/scripts

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: ${{ inputs.node_version }}

      - name: Install Redocly CLI
        run: npm i -g @redocly/cli

      - name: Build Redoc HTML previews
        run: |
          set -euo pipefail
          mkdir -p redoc-previews
          read -r -a SPECS <<< "${{ needs.detect.outputs.changed_specs }}"
          for spec in "${SPECS[@]}"; do
            [ -z "$spec" ] && continue
            api_dir="$(dirname "$spec")"
            api_name="$(echo "$api_dir" | tr '/' '-')"
            out_html="redoc-previews/${api_name}.html"
            .wendara-ci-actions/scripts/api-first/redoc-build.sh "$spec" "$out_html"
            echo "Generated: '$out_html'"
          done

      - name: Upload Redoc previews
        uses: actions/upload-artifact@v4
        with:
          name: redoc-previews
          path: redoc-previews/
          retention-days: 7

  publish:
    # Publish changed specs as Maven artifacts to GitHub Packages (or mavenLocal in local runs).
    # Hardened against false positives: we pre-filter to avoid 409 conflicts
    # by skipping artifacts that already exist in the registry (HEAD check).
    name: Publish changed specs
    runs-on: ubuntu-latest
    needs: [ detect, validate, guard ]  # ensure validations pass before publishing
    if: needs.detect.outputs.any_changed == 'true' && inputs.publish_enabled
    outputs:
      released: ${{ steps.flag.outputs.released }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install yq (required by Gradle build.kts and filtering)
        run: |
          sudo curl -sSL -o /usr/local/bin/yq https://github.com/mikefarah/yq/releases/download/v4.44.3/yq_linux_amd64
          sudo chmod +x /usr/local/bin/yq
          yq --version

      - name: Setup Java
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: ${{ inputs.java_version }}
          cache: gradle

      - name: Derive release channel
        id: channel
        shell: bash
        run: |
          if [[ "${GITHUB_REF}" == "refs/heads/main" ]]; then
            echo "value=RELEASE" >> $GITHUB_OUTPUT
          else
            echo "value=SNAPSHOT" >> $GITHUB_OUTPUT
          fi

      - name: Resolve publish list (skip already-published artifacts)
        id: filter
        env:
          CHANGED_SPECS: ${{ needs.detect.outputs.changed_specs }}
          REQUIRE_LISTED_ONLY: ${{ inputs.require_listed_only }}
          GITHUB_TOKEN: ${{ secrets.PACKAGES_TOKEN || github.token }}
        shell: bash
        run: |
          set -euo pipefail
          read -r -a SPECS <<< "${CHANGED_SPECS}"
          ROOT_META="metadata.yml"

          # Build a whitelist when require_listed_only=true (by exact spec path)
          declare -A WHITE=()
          if [[ "${REQUIRE_LISTED_ONLY}" == "true" && -f "${ROOT_META}" ]]; then
            # Expected: root metadata lists allowed spec paths under a key like 'listedPaths'
            # If your key name differs, adjust '.listedPaths[]' accordingly.
            while IFS= read -r p; do
              [[ -n "$p" ]] && WHITE["$p"]=1
            done < <(yq '.listedPaths[]' "${ROOT_META}" 2>/dev/null || true)
          fi

          must_publish() {
            local spec="$1"
            local dir; dir="$(dirname "$spec")"
            local meta="${dir}/metadata.yml"

            # Respect require_listed_only
            if [[ "${REQUIRE_LISTED_ONLY}" == "true" && ${#WHITE[@]} -gt 0 ]]; then
              if [[ -z "${WHITE[$spec]:-}" ]]; then
                echo "skip: not listed -> ${spec}" >&2
                return 1
              fi
            fi

            # Read per-API metadata (publish flag defaults to true)
            local publish="true"
            local groupId="" artifactId="" version=""
            if [[ -f "$meta" ]]; then
              publish="$(yq '.publish // true' "$meta" 2>/dev/null || echo true)"
              groupId="$(yq -r '.groupId // ""' "$meta" 2>/dev/null || echo "")"
              artifactId="$(yq -r '.artifactId // ""' "$meta" 2>/dev/null || echo "")"
              version="$(yq -r '.version // ""' "$meta" 2>/dev/null || echo "")"
            fi

            if [[ "${publish}" != "true" ]]; then
              echo "skip: publish=false -> ${spec}" >&2
              return 1
            fi

            # If any coord is missing, we cannot HEAD-check; defer to Gradle
            if [[ -z "$groupId" || -z "$artifactId" || -z "$version" ]]; then
              echo "no-check: missing coords -> ${spec}" >&2
              return 0
            fi

            # HEAD check against GH Packages. If 200 -> already exists (skip).
            local repo="https://maven.pkg.github.com/wendara-org/wendara-api-definitions"
            local groupPath="${groupId//./\/}"
            local url="${repo}/${groupPath}/${artifactId}/${version}/${artifactId}-${version}.zip"

            local code
            code=$(curl -s -o /dev/null -w "%{http_code}" -I \
              -H "Authorization: Bearer ${GITHUB_TOKEN}" "$url" || true)

            if [[ "$code" == "200" ]]; then
              echo "skip: exists (409 avoided) -> ${spec}" >&2
              return 1
            fi

            # Otherwise, publish
            return 0
          }

          FILTERED=()
          for spec in "${SPECS[@]}"; do
            [[ -z "$spec" ]] && continue
            if must_publish "$spec"; then
              FILTERED+=("$spec")
            fi
          done

          if [[ ${#FILTERED[@]} -eq 0 ]]; then
            echo "filtered_specs=" >> $GITHUB_OUTPUT
            echo "published_any=false" >> $GITHUB_OUTPUT
            echo "Nothing to publish after filtering (already in registry or not listed)."
          else
            FILTERED_SPECS="$(printf "%s " "${FILTERED[@]}")"
            echo "filtered_specs=${FILTERED_SPECS}" >> $GITHUB_OUTPUT
            echo "published_any=true" >> $GITHUB_OUTPUT
            printf "Will publish:\n  - %s\n" "${FILTERED[@]}"
          fi

      - name: Publish (changed-only, filtered)
        if: steps.filter.outputs.filtered_specs != ''
        env:
          GITHUB_TOKEN: ${{ secrets.PACKAGES_TOKEN || github.token }}
        run: |
          CHANGED="$(echo '${{ steps.filter.outputs.filtered_specs }}' | xargs)"
          ./gradlew --no-daemon --no-configuration-cache \
            publishChangedSpecs \
            -PchangedSpecs="$CHANGED" \
            -PreleaseChannel="${{ steps.channel.outputs.value }}" \
            -PrequireListedOnly="${{ inputs.require_listed_only }}"

      - name: Flag release output
        id: flag
        shell: bash
        run: |
          # We consider "released=true" only when publishing on main (stable channel)
          # AND there was at least one spec to publish post-filtering.
          if [[ "${{ steps.channel.outputs.value }}" == "RELEASE" && "${{ steps.filter.outputs.published_any }}" == "true" ]]; then
            echo "released=true" >> $GITHUB_OUTPUT
          else
            echo "released=false" >> $GITHUB_OUTPUT
          fi

  sync:
    name: Sync main â†’ develop
    runs-on: ubuntu-latest
    needs: [ publish ]
    if: needs.publish.outputs.released == 'true'
    permissions:
      contents: write
      pull-requests: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.PACKAGES_TOKEN || github.token }}

      - name: Configure Git identity
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

      - name: Create sync branch and merge
        id: merge
        run: |
          git fetch origin main develop
          git checkout -b chore/sync-main-into-develop origin/develop

          # Merge with 'ours' strategy to create history commit without changing content
          git merge -s ours --no-ff origin/main -m "chore(sync): record main tip in develop history"

          # Check if tree changed compared to develop
          if git diff-tree --quiet origin/develop HEAD; then
            echo "has_changes=false" >> $GITHUB_OUTPUT
          else
            echo "has_changes=true" >> $GITHUB_OUTPUT
          fi

      - name: Push directly to develop (no content changes)
        if: steps.merge.outputs.has_changes == 'false'
        run: |
          # Direct push since it's only a history merge commit
          git push origin HEAD:develop

      - name: Create PR (if there are actual changes)
        if: steps.merge.outputs.has_changes == 'true'
        env:
          GH_TOKEN: ${{ secrets.PACKAGES_TOKEN || github.token }}
        run: |
          git push -f origin chore/sync-main-into-develop

          # Check if PR already exists
          existing_pr=$(gh pr list --head chore/sync-main-into-develop --base develop --json number --jq '.[0].number')

          if [ -n "$existing_pr" ]; then
            echo "âœ… PR #$existing_pr already exists"
          else
            gh pr create \
              --base develop \
              --head chore/sync-main-into-develop \
              --title "chore(sync): merge main into develop" \
              --body "$(cat <<EOF
          ## ðŸ”„ Sync main â†’ develop

          Automated PR to merge changes from **main** back into **develop** after release.

          âš ï¸ This PR contains actual content changes that need review.

          **Source:** \`main\`
          **Target:** \`develop\`
          EOF
              )" \
              --label chore \
              --label sync
          fi

      - name: Summary
        run: |
          if [ "${{ steps.merge.outputs.has_changes }}" == "false" ]; then
            echo "âœ… Pushed merge commit directly to develop (history sync only)"
          else
            echo "ðŸ“ Created PR with content changes for review"
          fi
